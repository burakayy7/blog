<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://burakayy.com/blog/tag/pid/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://burakayy.com/blog/" rel="alternate" type="text/html" />
  <updated>2024-10-13T17:03:59+00:00</updated>
  <id>https://burakayy.com/blog/tag/pid/feed.xml</id>

  
  
  

  
    <title type="html">Burak Ayyorgun | </title>
  

  
    <subtitle>My Blog for Technical Projects</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Self-Balancing Arduino Robot</title>
      <link href="https://burakayy.com/blog/Self-Balancing-Robot" rel="alternate" type="text/html" title="Self-Balancing Arduino Robot" />
      <published>2021-06-14T00:00:00+00:00</published>
      <updated>2021-06-14T00:00:00+00:00</updated>
      <id>https://burakayy.com/blog/Self-Balancing-Robot</id>
      <content type="html" xml:base="https://burakayy.com/blog/Self-Balancing-Robot">&lt;p&gt;I have been wanting to make this project for some time now. I have seen others do them with really expensive motors and devices and I wanted to test and see if I could build a functioning prototype with the $5 materials I had laying around my room.&lt;/p&gt;

&lt;p&gt;I first, looked at other’s robots and how they designed their’s. I also looked at which devices I had. Now for the main controller, I just used a 5v Arduino Nano board. But the IMu sensor was the challenging part. I first thought I could use a complimentary filter with the MPU6050, but that prooved to cause some oscillations and false orientation data. The cheap accelerometers would read too much vibrations and the gyros drift would sustain it well for long self-balancing. EVEN with the complimentary filter. Look, the comlimentary filter is great. But I wanted to remove as many failure points as possible for the first version. So for the first prototype, I decided to go the easy route: getting quaternions from the BNO055 and converting those to Eular angles.&lt;/p&gt;

&lt;p&gt;For the motors I had only geared DC motors. These are super cheap and shouldn’t be used on robots like this! I wonder if this will cause me any pain in the future?&lt;/p&gt;

&lt;p&gt;And to drive those motors I had a L298N motor driver. This for sure will cause me problems and I knew it. I was just too broke to buy a better solution. This driver draws a lot of current. In fact, there is a voltage drop, from the input battery terminal to the motor driving terminals, by more than 2 volts. This means, that if I were to hook up a 9v battery, the motors would only see about 7 volts. And I am not even talking about the loss in current!!&lt;/p&gt;

&lt;p&gt;So, this driver is inefficient. Oh well!&lt;/p&gt;

&lt;p&gt;For the main power source, I needed a battery that could provide a lot of power. However, I didn’t have a rechargable battery. I tried 9v batteris, 2 9v batteries. and even some cheap NiCds. But I eventually found that the best results are with 3 9v batteries in series. Producing a total of 27 volts. Now I don’t exactly know what this did the the 6v rated motors, but it was enough to provide the current needed for the robot. But only for a short amount of time, like 5-10 tests and then it was done.&lt;/p&gt;

&lt;p&gt;For the main frame, I went to CAD… NOOO. I was broke back then and didn’t have a 3D printer. So I built the frame from cardboard cut with my 5 dollar scissors and barbecue skewers. I wanted a 2 ‘story’ build where the battery and IMU would go on the top. Ideally the most mass should go on the top, since this is essentially an inverted pendulum. And the more mass an object has, the more inertia it has. So, the robot would have more time to react and stabilize it’s own weight, if most of the weight was on top.&lt;/p&gt;

&lt;p&gt;In the end, I sketch-up something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/sbrSketch.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and the dimensions:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/sbrDim.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In order to control the robot, it needs to know it’s orientation, more specifically it’s tilt. So, we can use a sensor called an Inertial Measurment Unit (IMU for short). 6-axis IMUs have a 3 axis accelerometer and a 3 axis gyroscope. We can use these and some math to get our rotation in Eular angles. However, this is usually sensative to vibration and gimble lock. So instead we can use something called Quaternions. Quaternions are the numbers that extend the complex numbers and can define 3 dimensional rotations with 4 numbers. However, most IMU’s don’t have quaternions. So, I used the BNO055 IMU and I explain how to get these measurments in &lt;a href=&quot;https://burakayy.com/blog/IMU-Measurments&quot;&gt;this blog post&lt;/a&gt;. Please go check that out and come back here when you feel ready.&lt;/p&gt;

&lt;p&gt;Once the Eular angles are achieved, we need a way to control this. After some research, I chose the PID controller to control my robot. I learned how to implement this in Paul McWhorter’s &lt;a href=&quot;https://www.youtube.com/watch?v=t7ImNDOQIzM&amp;amp;list=PLGs0VKk2DiYwEo-k0mjIkWXlkrJWAU4L9&amp;amp;index=26&quot;&gt;IMU class&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here is how I implemented a PID controller:&lt;/p&gt;

&lt;p&gt;First, you need to get your error. Like let’s say an angle of 0 is the target, but we read 10 degrees. Then the error is 10 degrees. Here is the code for getting all the terms in PID, which I will explain later:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;rollErrorOld&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rollError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//get the old rollError&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rollError&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rollTarget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rollActual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//get the current rollError&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rollErrorChange&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rollError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rollErrorOld&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//get the change in the rollError; our newError minus the oldError = change in Error&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rollErrorSlope&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rollErrorChange&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//get the slope of our error; the change in error over the chaneg in time is the 'slope' of the error 'line' if the y-axis is error and the x-axis is time&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rollErrorArea&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rollErrorArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rollError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//the area under the curve between the error curve and the x-axis&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And all of these should be the same for pitch, just the variable names change.&lt;/p&gt;

&lt;p&gt;But what is PID?&lt;/p&gt;

&lt;p&gt;Well, I explained that in &lt;a href=&quot;https://burakayy.com/blog/What-is-PID&quot;&gt;this blog post&lt;/a&gt;. You should go check it out, and come back here when you feel confident on PID controllers.&lt;/p&gt;

&lt;p&gt;Now that we know what a PID controller is and how it works, let’s see how this will help control our robot. The algorithm calculates our current error in degrees and the PID contoller outputs a number accordingly to the input. And we need to use that output value to control our motors. Since our input is in degrees, our output will also be in degrees. But the cheap DC motors don’t accept values in “degrees”. You can only apply a voltage or a PWM signal to the motors.&lt;/p&gt;

&lt;p&gt;So a decent engineer would create a function that maps degrees to the motor’s rotation and speed, and use that function to control the motors. However, 13 year old me was too lazy and directly multiplied the degrees by a combonation of numbers to directly control the motors.&lt;/p&gt;

&lt;p&gt;This was probably a major reason to as why the robot didn’t succeed.&lt;/p&gt;

&lt;p&gt;Instead what I did was use the output by the controller and scale them for PWM and use that to control the motors. Also, I would change the direction of the spin according to the sign of the PID output. And I hoped that this would be enough to achieve maybe a few seconds of self-stabilization. And I was close, I got the robot to stand upright, balancing, for a few seconds, then it would fall. This was partly due to the usb cable being attached to the robot because I didn’t have a good way to power the Arduino and the motor driver.&lt;/p&gt;

&lt;p&gt;If you want to watch a short video of it in action:&lt;/p&gt;

&lt;p&gt;Another reason to as why it didn’t work is due to the poor structure of the robot. If you make a robot out of cardboard and hot glue it together with barbaque skewers, you’re going to get something very inperfect. And when the robot is trying to balance, it will cause oscillations. These oscillations in some cases can be dampened with the PID controller, but in this case, it was a gonner.&lt;/p&gt;

&lt;p&gt;After I accomplished a few seconds of balancing after days of hard work, I felt like I should call this a success and blame the failures on the poor quality of equipment.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="pid" />
      

      
        <summary type="html">I have been wanting to make this project for some time now. I have seen others do them with really expensive motors and devices and I wanted to test and see if I could build a functioning prototype with the $5 materials I had laying around my room.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">What is PID?</title>
      <link href="https://burakayy.com/blog/What-is-PID" rel="alternate" type="text/html" title="What is PID?" />
      <published>2021-06-15T00:00:00+00:00</published>
      <updated>2021-06-15T00:00:00+00:00</updated>
      <id>https://burakayy.com/blog/What-is-PID</id>
      <content type="html" xml:base="https://burakayy.com/blog/What-is-PID">&lt;p&gt;This is a quick post on what PID is and how to implement it.&lt;/p&gt;

&lt;p&gt;For startes, PID stands for &lt;strong&gt;Proportional-Integral-Derivative&lt;/strong&gt;. And PID is a closed-loop feedback controller. That means that when the controller outputs a value, that output will change the input, which will result in another different output to be produced. And this systems goes on and on until the main program is terminated.&lt;/p&gt;

&lt;p&gt;When are PID Controllers used?&lt;/p&gt;

&lt;p&gt;Well, in almost any application that needs to be actively controlled. Such as: autopilot UAVs, self-balancing robots, drones, battery chargers, etc.&lt;/p&gt;

&lt;p&gt;So what &lt;strong&gt;exactly&lt;/strong&gt; are PID controllers?&lt;/p&gt;

&lt;h3 id=&quot;well-lets-start-off-with-the-proportional-part&quot;&gt;Well, let’s start off with the proportional part:&lt;/h3&gt;

&lt;p&gt;As you might of thought, this part produces a value &lt;strong&gt;proportional&lt;/strong&gt; to the error. For example: let’s assume we are making a drone. And the orientation sensor detects that we are tilting by 20 degrees. And let’s say that the P Value (or the Proportional Value) is 0.5. Then the output of the P part will be -20*0.5 which is -10 degrees. We say negative, because our target value, which is 0 minus our error is a negative value. If our error was 90 degrees, then the P Value would be -45 degrees. Essentially, the output is proportional to the error with respect to the P Value. However, this alone isn’t very affective in the real world. Because in the real world there is momentum. Which means our system will overshoot, which causes oscillations in the system.&lt;/p&gt;

&lt;p&gt;Next, what does the Integral Part mean. And to better understand why this is important, let’s first know why the Derivative term is there.&lt;/p&gt;

&lt;h3 id=&quot;the-d-term-or-the-derivative&quot;&gt;the D term, or the Derivative:&lt;/h3&gt;

&lt;p&gt;If you have noticed, the I and D parts are names commonly used in Calculus. This is because we actually are using concepts from Calculus. The Derivative term looks at our error ‘curve’ over time. Actually, it’s not over time but this is what I mean: Imagine our error values are being plotted on an x-y plane, where the x-axis is time and the y-axis is the error. Now this will form some sort of ‘curve’ (I just mean a plot or graph). And by definition, the Derivative term is looking at the slope of our curve. Or basically, how fast are we going away or to our target value (in most systems this will be 0 or the x-axis)? And the D term changes accordingly to that value. Let’s go through an example (sticking to the one above): Now let’s assume our D Value is say 10. And the slope of the error curve is negative, say -2. Then the output of the D function is (D Value * slope) or (10) * (-2) = -20. So we will be adding a negative value of 20 to the output of the P function which is -30. This will cause a bit more aggressive of a response, since our slope is somewhat high; which means we are moving fast, so we require a more aggressive counter. This term, where we slightly modify the output of the P term, depending on how fast we’re moving results in &lt;strong&gt;NO OVERSHOOTING&lt;/strong&gt;! This alone is a pretty good system. However, there are some scenarios where the error is not at the target but the specific P and D terms aren’t affective at getting it back to the target. This is when the Intergal term comes in.&lt;/p&gt;

&lt;h3 id=&quot;finally-the-integral-term&quot;&gt;Finally, the Integral term:&lt;/h3&gt;

&lt;p&gt;This looks at the area under our curve relative to our target value, the line y=targetVal. How it calculates the area isn’t exact, but it is an apporximation. The equation for the Integral term is adding our old area term to the multiplication of our error value and the change in time (or the time interval which we last calculated our error).&lt;/p&gt;

&lt;p&gt;In Arduino Code:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pitchErrorArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pitchErrorArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pitchError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And if you’ve noticed, this is actually the area of a rectangle, where the length is the time intevral and the height is the error. And you’ve probably also noticed that this doesn’t always match up with the actual graph, but it’s a pretty good approximation.&lt;/p&gt;

&lt;p&gt;Now, this is when the Integral term is useful:&lt;/p&gt;

&lt;p&gt;Let’s go back to the graph. Our system without the Integral term is pretty good, but it isn’t affective at long term stuff. Like when our error is really close to the target, but isn’t actually equal to it, and over time, this makes a difference. So as a solution, we take the area of the part between our target and the graph, and add them up over time (this is called Integrating) to get our current area. And we divide this area by a sufficiently large number (or multiply this area by a sufficiently small number, like 0.0001, which is our Integral part) which we then add to our correcting value; which will over time be making small adjustments to get us closer to our target. And that completes our PID system.&lt;/p&gt;

&lt;p&gt;If you want a visual:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/PID_en.png&quot; alt=&quot;PID Contoller block diagram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Also, depending on the system, you will need to play around with the P, I, and D values to perfectly tune it to your specific system. This takes lots of trial and error, but is definetly worth it!&lt;/p&gt;

&lt;p&gt;If you want more resources:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/PID_controller&quot;&gt;wiki&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=t7ImNDOQIzM&amp;amp;list=PLGs0VKk2DiYwEo-k0mjIkWXlkrJWAU4L9&amp;amp;index=26&quot;&gt;McWhorter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hope you learned something!!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name></name>
        
        
      </author>

      

      
        <category term="pid" />
      

      
        <summary type="html">This is a quick post on what PID is and how to implement it.</summary>
      

      
      
    </entry>
  
</feed>
